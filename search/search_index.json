{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Confluence: https://rendocs.atlassian.net/wiki/home</p>"},{"location":"glib/datatypes/","title":"Data Types","text":""},{"location":"glib/datatypes/#glist-and-gslist","title":"GList and GSList","text":"<p>Use for:</p> <ul> <li>Storing a list of elements where you need to frequently insert or remove elements from both ends or the middle.</li> <li>Maintaining the order of elements, as GList preserves the order in which elements are added.</li> <li>Scenarios where the number of elements changes dynamically.</li> </ul> <p>Avoid for:</p> <ul> <li>Scenarios where random access to elements is needed, as it requires O(n) time to access an element.</li> </ul>"},{"location":"glib/datatypes/#ghashtable","title":"GHashTable","text":"<p>Use for:</p> <ul> <li>Associating keys with values and performing fast lookups based on keys.</li> <li>Scenarios where the data can be efficiently hashed.</li> </ul> <p>Avoid for:</p> <ul> <li>When the data size is small and the overhead of a hash table is not justified.</li> </ul>"},{"location":"glib/datatypes/#gqueue","title":"GQueue","text":"<p>Use for:</p> <ul> <li>Managing a collection of elements with operations at both ends, like implementing stacks, queues, or deques.</li> <li>Scenarios where you need to add or remove elements from both ends efficiently.</li> </ul> <p>Avoid for:</p> <ul> <li>Random access or accessing elements in the middle, as it requires traversing the list.</li> </ul>"},{"location":"glib/datatypes/#garray","title":"GArray","text":"<p>Use for:</p> <ul> <li>Storing a sequence of elements where you need efficient random access and can tolerate occasional reallocations when the array grows.</li> <li>Tasks where the number of elements is known or approximately known in advance.</li> </ul> <p>Avoid for:</p> <ul> <li>Frequent insertions or deletions in the middle of the array, as it may involve shifting elements.</li> </ul>"},{"location":"glib/datatypes/#gptrarray","title":"GPtrArray","text":"<p>Use for:</p> <ul> <li>Storing pointers to objects or dynamically allocated memory, especially when you need to store large data structures that are accessed frequently.</li> <li>When you need to maintain an ordered list of pointers.</li> </ul> <p>Avoid for:</p> <ul> <li>Directly storing non-pointer data types unless you intend to manage the memory manually.</li> </ul>"},{"location":"glib/datatypes/#gtree","title":"GTree","text":"<p>Use for:</p> <ul> <li>Maintaining a sorted set of elements where you need to perform operations like range queries, in-order traversal, or when you need sorted order.</li> <li>Associating keys with values similar to GHashTable, but with the added benefit of ordering.</li> </ul> <p>Avoid for:</p> <ul> <li>Simple key-value pairs where the key order is not required, in which case GHashTable might be more efficient.</li> </ul>"},{"location":"glib/datatypes/#gstring","title":"GString","text":"<p>Use for:</p> <ul> <li>Handling mutable strings where concatenation, appending, or other manipulations are frequent.</li> <li>Situations where you need a string that can grow dynamically.</li> </ul> <p>Avoid for:</p> <ul> <li>Simple, fixed-length strings where you can use regular char* to avoid the overhead.</li> </ul>"},{"location":"glib/datatypes/#gbytearray","title":"GByteArray","text":"<p>Use for:</p> <ul> <li>Managing a sequence of bytes where you might need to append or remove bytes dynamically, such as constructing binary data for file I/O or network communication.</li> <li>Situations where you need efficient access to raw byte data.</li> </ul> <p>Avoid for:</p> <ul> <li>Storing data that is not byte-oriented, like large numbers or text strings that require character encoding.</li> </ul>"},{"location":"glib/datatypes/#gvariant","title":"GVariant","text":"<p>Use for:</p> <ul> <li>Storing and transmitting heterogeneous data types, particularly when you need to serialize or deserialize data for D-Bus communication or configuration storage.</li> <li>Situations where data can be of various types, and you need a flexible, type-safe way to handle it.</li> </ul> <p>Avoid for:</p> <ul> <li>Simple homogeneous data types, where the overhead of using a variant is unnecessary.</li> </ul>"},{"location":"glib/datatypes/#gbytes","title":"GBytes","text":"<p>Use for:</p> <ul> <li>Managing immutable sequences of bytes, especially when sharing or passing around data that shouldn't change, such as cryptographic data, file contents, or network payloads.</li> <li>When you need to ensure the integrity of the data across different parts of your application.</li> </ul> <p>Avoid for:</p> <ul> <li>Mutable data or data that needs frequent modification, as GBytes is designed for immutability.</li> </ul>"},{"location":"glib/datatypes/#gkeyfile","title":"GKeyFile","text":"<p>Use for:</p> <ul> <li>Reading and writing configuration files in a format similar to INI files, where you need to store key-value pairs under sections.</li> <li>Managing application settings that can be easily loaded and saved to text files.</li> </ul> <p>Avoid for:</p> <ul> <li>Storing complex data structures that don\u2019t fit well into a key-value model.</li> </ul>"},{"location":"glib/datatypes/#gvariantdict","title":"GVariantDict","text":"<p>Use for:</p> <ul> <li>Managing dynamic dictionaries of GVariant key-value pairs, especially when you need to construct or parse hierarchical data structures for configurations or data interchange.</li> <li>Scenarios where you need a flexible, type-safe dictionary that can handle various data types.</li> </ul> <p>Avoid for:</p> <ul> <li>Situations where the data does not require the flexibility of GVariant, or when a simpler data structure suffices.</li> </ul>"},{"location":"glib/datatypes/#summary","title":"Summary","text":"<p>The choice of GLib data types depends on the specific task and the characteristics of the data you're working with:</p> <ul> <li>Linked Lists (GList, GSList): Use when you need dynamic lists with frequent insertions/deletions.</li> <li>Arrays (GArray, GPtrArray, GByteArray): Use when you need efficient random access and can handle reallocations.</li> <li>Key-Value Stores (GHashTable, GTree): Use for fast lookups or maintaining sorted data.</li> <li>Queues (GQueue): Use for managing collections where both ends are accessed frequently.</li> <li>Strings (GString, GBytes): Use for handling dynamic strings or immutable byte sequences.</li> <li>Complex Data (GVariant, GVariantDict): Use for handling heterogeneous or serialized data.</li> </ul>"},{"location":"linuxtools/fortinet/","title":"Fortinet on ubuntu","text":"<p>Step1: Install openfortivpn and its corresponding NetworkManager plugin:</p> <pre><code>sudo apt update\nsudo apt install openfortivpn network-manager-fortisslvpn-gnome\nsudo systemctl daemon-reload\nsudo systemctl restart NetworkManager\n</code></pre> <p>Step2: Use the gnome-control-center to configure the desired VPN</p> <p>Step3: profit?</p>"},{"location":"linuxtools/jq/","title":"jq","text":"<p>Parse, manipulate and output JSON data.</p>"},{"location":"linuxtools/jq/#examples","title":"Examples","text":"<pre><code>list_devices.sh | jq '.[] | {uuid:.Uuid,mode:.Model,name:.Name,type:.Type}'\n</code></pre> <pre><code>list_devices.sh | jq '.[] | {uuid:.Uuid,mode:.Model,name:.Name,type:.Type,tech:.Technology,online:.Online,appliance:.Parameters[]|select(has(\"MeasuredApplianceType\"))|.MeasuredApplianceType} | select(.type | contains(\"meter\"))'\n</code></pre>"}]}